# -*- coding: utf-8 -*-
"""getdata.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MVoGKVuiw4TD9NtbHvOySBrBwjCbwhFk
"""

!apt-get install tor
!service tor start
!pip install pyupbit
!pip install pybit

# 연결된 Tor의 SOCKS proxy 사용
import socket
import socks

socks.set_default_proxy(socks.SOCKS5, "127.0.0.1", 9050)
socket.socket = socks.socksocket

# IP 주소가 변경된 것을 확인
import requests
print(requests.get('https://httpbin.org/ip').text)

import sqlite3
import requests
import time

BYBIT_BASE_URL = "https://api.bybit.com"
UPBIT_BASE_URL = "https://api.upbit.com/v1"

# Rate Limit 대기 시간 (초)
RATE_LIMIT_DELAY = 0.1  # 요청 간 대기 시간

# Bybit 지원 심볼 조회
def get_bybit_symbols():
    endpoint = "/v5/market/instruments-info"
    url = f"{BYBIT_BASE_URL}{endpoint}"
    params = {"category": "linear"}
    response = requests.get(url, params=params)
    time.sleep(RATE_LIMIT_DELAY)  # 요청 후 대기
    if response.status_code == 200:
        data = response.json()
        if data.get("retCode") == 0:
            return [item['symbol'] for item in data['result']['list']]
        else:
            raise Exception(f"Bybit API Error: {data.get('retMsg')}")
    else:
        raise Exception(f"Bybit HTTP Error: {response.status_code}, {response.text}")

# Upbit 지원 마켓 조회
def get_upbit_markets():
    url = f"{UPBIT_BASE_URL}/market/all"
    response = requests.get(url)
    time.sleep(RATE_LIMIT_DELAY)  # 요청 후 대기
    if response.status_code == 200:
        data = response.json()
        return {item['market']: item['korean_name'] for item in data if item['market'].startswith("KRW-")}
    else:
        raise Exception(f"Upbit HTTP Error: {response.status_code}, {response.text}")

# Bybit와 Upbit 공통 심볼 가져오기
def get_common_symbols():
    bybit_symbols = get_bybit_symbols()
    upbit_markets = get_upbit_markets()

    # 공통 심볼 찾기
    common_symbols = []
    for symbol in bybit_symbols:
        if symbol.endswith("USDT"):
            base = symbol.replace("USDT", "")
            upbit_market = f"KRW-{base}"
            if upbit_market in upbit_markets:
                common_symbols.append(base)  # "USDT" 접미사를 제거한 심볼만 저장

    return common_symbols

# DB 연결 및 테이블 생성
def create_db_connection(db_name="symbols.db"):
    conn = sqlite3.connect(db_name)
    return conn

# 심볼 테이블 생성 함수
def create_table_if_not_exists(conn):
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE IF NOT EXISTS symbols (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        symbol TEXT UNIQUE)''')
    conn.commit()

# 공통 심볼을 DB에 저장
def save_symbols_to_db(symbols, db_name="symbols.db"):
    conn = create_db_connection(db_name)

    # 테이블 생성
    create_table_if_not_exists(conn)

    cursor = conn.cursor()

    # 심볼을 DB에 저장
    for symbol in symbols:
        cursor.execute("INSERT OR IGNORE INTO symbols (symbol) VALUES (?)", (symbol,))

    conn.commit()
    conn.close()
    print(f"Symbols saved to {db_name}")

if __name__ == "__main__":
    common_symbols = get_common_symbols()
    print(f"Common Symbols: {common_symbols}")
    save_symbols_to_db(common_symbols)

import sqlite3
import pandas as pd
from datetime import datetime, timedelta, timezone
import time
import pyupbit
from pybit.unified_trading import HTTP
import yfinance as yf

# Bybit API 설정
session = HTTP(testnet=False)

# 공통 기간 계산
def calculate_time_period(day):
    end_time = datetime.now(timezone.utc)  # 현재 UTC 시간
    start_time = end_time - timedelta(days=day)
    start_ms = int(start_time.timestamp() * 1000)
    end_ms = int(end_time.timestamp() * 1000)
    return start_ms, end_ms , start_time, end_time

# USD/KRW 데이터 가져오기 함수
def fetch_krw_usd_multiple_requests(interval, day, max_retries=5, retry_delay=5):
    start_ms, end_ms, start_time, end_time = calculate_time_period(day)
    start_time = end_time - timedelta(days=8)
    all_data = pd.DataFrame()

    # 5일씩 데이터를 요청
    for i in range(day//5+1):
        retries = 0
        while retries < max_retries:
            try:
                data = yf.download('KRW=X', interval=f"{interval}m", start=start_time, end=end_time)
                if not data.empty:
                    data = data[['Close']].rename(columns={"Close": "KRW_USD"})
                    # datetime 인덱스를 UTC로 설정 (datetime 객체로 변환 후 타임존 설정)
                    data.index = pd.to_datetime(data.index)  # ensure index is datetime
                    data.index = data.index.tz_localize('UTC', ambiguous='NaT')
                    all_data = pd.concat([all_data, data])
                break  # 데이터 가져오기가 성공하면 재시도 종료

            except Exception as e:
                print(f"Error fetching data for KRW/USD: {e}")
                retries += 1
                if retries < max_retries:
                    print(f"Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    print(f"Max retries reached for KRW/USD. Skipping this request.")
                    break  # 재시도 횟수 초과 시 중지

        # 5일씩 이전으로 이동
        end_time = start_time
        start_time = end_time - timedelta(days=8)

    # 중복된 데이터 제거 후 리셋
    all_data = all_data.sort_index()
    return all_data

def get_usdt(interval, day, max_retries=5, retry_delay=5):
    start_ms, end_ms, start_time, end_time = calculate_time_period(day)
    end_time_upbit = end_time
    start_time_upbit = end_time - timedelta(days=1)  # days 일수만큼 기간 설정
    all_data = pd.DataFrame()

    for i in range(day):  # 5일 단위로 데이터를 요청
        retries = 0
        while retries < max_retries:
            try:
                df = pyupbit.get_ohlcv(ticker=f"KRW-USDT", interval=f"minute{interval}", count=1600//interval, to=end_time_upbit, period=0.1)

                if df is None or df.empty:  # 데이터가 없거나 비어있으면 종료
                    print(f"Upbit 데이터 없음: USDT")
                    break

                print(f"{end_time_upbit}")
                print(f"{start_time_upbit}")

                # 5일씩 이전으로 이동
                end_time_upbit = start_time_upbit
                start_time_upbit = end_time_upbit - timedelta(days=1)

                df.index = df.index.tz_localize("Asia/Seoul").tz_convert("UTC")  # UTC로 변환
                df = df[["close"]]  # 'close' 열만 남기기
                df = df.rename(columns={"close": f"KRW-USDT"})  # 열 이름 변경
                df.index.name = 'timestamp'  # 인덱스를 'timestamp'로 설정

                # 기존 데이터와 새로운 데이터 합치기 (timestamp 기준으로 최신 데이터로 덮어쓰는 방식)
                all_data = pd.concat([all_data, df])
                break  # 데이터 가져오기가 성공하면 재시도 종료

            except Exception as e:
                print(f"Error fetching data for USDT: {e}")
                retries += 1
                if retries < max_retries:
                    print(f"Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    print(f"Max retries reached for USDT. Skipping this request.")
                    break  # 재시도 횟수 초과 시 중지

    if all_data.empty:
        print(f"Upbit USDT 데이터가 반환되지 않았습니다: USDT")

    # 중복된 timestamp 제거 (최신 데이터 우선)
    all_data = all_data[~all_data.index.duplicated(keep='last')]

    # timestamp 기준으로 오름차순 정렬
    all_data = all_data.sort_index()

    # NaN 값을 이전 값으로 채우기 (결측값을 앞선 값으로 채움)
    all_data = all_data.ffill()

    return all_data


def get_upbit_close_data(symbol, interval, day, max_retries=5, retry_delay=5):
    start_ms, end_ms, start_time, end_time = calculate_time_period(day)
    end_time_upbit = end_time
    start_time_upbit = end_time - timedelta(days=1)  # days 일수만큼 기간 설정
    all_data = pd.DataFrame()

    for i in range(day):  # 5일 단위로 데이터를 요청
        retries = 0
        while retries < max_retries:
            try:
                df = pyupbit.get_ohlcv(ticker=f"KRW-{symbol}", interval=f"minute{interval}", count=1600//interval, to=end_time_upbit, period=0.1)

                if df is None or df.empty:  # 데이터가 없거나 비어있으면 종료
                    print(f"Upbit 데이터 없음: {symbol}")
                    break

                print(f"{end_time_upbit}")
                print(f"{start_time_upbit}")

                # 5일씩 이전으로 이동
                end_time_upbit = start_time_upbit
                start_time_upbit = end_time_upbit - timedelta(days=1)

                df.index = df.index.tz_localize("Asia/Seoul").tz_convert("UTC")  # UTC로 변환
                df = df[["close"]]  # 'close' 열만 남기기
                df = df.rename(columns={"close": f"KRW-{symbol}"})  # 열 이름 변경 (예: 'KRW-1INCH')
                df.index.name = 'timestamp'  # 인덱스를 'timestamp'로 설정

                # 기존 데이터와 새로운 데이터 합치기 (timestamp 기준으로 최신 데이터로 덮어쓰는 방식)
                all_data = pd.concat([all_data, df])
                break  # 데이터 가져오기가 성공하면 재시도 종료

            except Exception as e:
                print(f"Error fetching data for {symbol}: {e}")
                retries += 1
                if retries < max_retries:
                    print(f"Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    print(f"Max retries reached for {symbol}. Skipping this request.")
                    break  # 재시도 횟수 초과 시 중지

    if all_data.empty:
        print(f"Upbit 데이터가 반환되지 않았습니다: {symbol}")

    # 중복된 timestamp 제거 (최신 데이터 우선)
    all_data = all_data[~all_data.index.duplicated(keep='last')]

    # timestamp 기준으로 오름차순 정렬
    all_data = all_data.sort_index()

    # NaN 값을 이전 값으로 채우기 (결측값을 앞선 값으로 채움)
    all_data = all_data.ffill()

    return all_data


def get_bybit_close_data(symbol, interval, day, max_retries=5, retry_delay=5):
    start_ms, end_ms, start_time, end_time = calculate_time_period(day)
    start_time = end_ms - int(timedelta(hours=16).total_seconds() * 1000)
    end_time = end_ms
    all_data = pd.DataFrame()
    all_closes = []

    for i in range((24*day)//16 + 1):  # 하루씩 데이터를 요청
        retries = 0
        while retries < max_retries:
            try:
                response = session.get_kline(
                    category="linear",
                    symbol=f"{symbol}USDT",
                    interval=str(interval),
                    start=start_time,
                    end=end_time,  # 하루 데이터만 요청
                    limit=1000
                )

                # response['result']['list']에서 데이터 추출
                result_list = response['result'].get('list', [])
                if not result_list:
                    print(f"데이터가 없습니다: {symbol}")
                    break

                # 데이터가 있으면 all_closes 리스트에 추가
                for data in result_list:
                    all_closes.append([data[0], data[4]])  # timestamp와 close 값만 추출

                print(f"End Time (ms): {end_time}")
                print(f"Start Time (ms): {start_time}")

                # 하루씩 이전으로 이동
                end_time = start_time
                start_time = end_time - int(timedelta(hours=16).total_seconds() * 1000)
                time.sleep(0.1)
                break  # 데이터 가져오기가 성공하면 재시도 종료

            except Exception as e:
                print(f"Error fetching data for {symbol}: {e}")
                retries += 1
                if retries < max_retries:
                    print(f"Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    print(f"Max retries reached for {symbol}. Skipping this request.")
                    break  # 재시도 횟수 초과 시 중지

    if all_closes:
        # 데이터프레임 생성
        df = pd.DataFrame(all_closes, columns=["timestamp", symbol])
        df["timestamp"] = pd.to_datetime(df["timestamp"].astype(int), unit='ms', utc=True)
        df.set_index("timestamp", inplace=True)
        df = df.rename(columns={symbol: f"{symbol[:-4]}"})  # '1INCHUSDT' -> '1INCH'
        df.index.name = 'timestamp'  # 인덱스를 'timestamp'로 설정

        # 중복된 timestamp 처리 (최신 데이터만 유지)
        df = df[~df.index.duplicated(keep='last')]

        # timestamp 기준으로 오름차순 정렬
        df = df.sort_index(ascending=True)
        df = df.ffill()

    else:
        print(f"데이터가 없습니다: {symbol}")
        df = pd.DataFrame()

    return df



def get_all_symbols_from_db():
    conn = sqlite3.connect('symbols.db')
    cursor = conn.cursor()

    # symbols 테이블에서 모든 심볼을 가져옵니다.
    cursor.execute('SELECT symbol FROM symbols')
    symbols = [row[0] for row in cursor.fetchall()]

    conn.close()
    return symbols


def save_to_db(symbol, bybit_data, upbit_data):
    conn = sqlite3.connect('symbols.db')
    cursor = conn.cursor()

    # Upbit과 Bybit 데이터를 저장할 테이블 이름 생성 (특수 문자가 있을 수 있으므로 안전하게 따옴표로 감싸기)
    table_name = f"'{symbol}'"  # 테이블 이름을 따옴표로 감싸서 안전하게 처리

    # 심볼에 대한 테이블이 존재하지 않으면 생성
    cursor.execute(f'''
    CREATE TABLE IF NOT EXISTS {table_name} (
        timestamp DATETIME PRIMARY KEY,
        upbit_close REAL,
        bybit_close REAL
    )''')

    # KRW/USD 데이터를 저장할 테이블 (ex_rate)
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS ex_rate (
        timestamp DATETIME PRIMARY KEY,
        krw_usd REAL
    )''')

    # Upbit과 Bybit 데이터 병합
    if not upbit_data.empty and not bybit_data.empty:
        # 두 DataFrame을 timestamp 기준으로 병합 (left join)
        merged_data = pd.merge(upbit_data, bybit_data, left_index=True, right_index=True, how='outer', suffixes=('_upbit', '_bybit'))
        merged_data = merged_data.ffill()
        # 병합된 데이터 저장
        for timestamp, row in merged_data.iterrows():
            timestamp = timestamp.to_pydatetime()

            # 각 테이블에 데이터를 삽입 (기존의 timestamp가 있을 경우 덮어쓰기)
            cursor.execute(f'''
            REPLACE INTO {table_name} (timestamp, upbit_close, bybit_close) VALUES (?, ?, ?)
            ''', (timestamp, row['KRW-' + symbol] if 'KRW-' + symbol in row else None, row[bybit_data.columns[0]] if bybit_data.columns[0] in row else None))

    # 변경 사항 커밋
    conn.commit()
    conn.close()

def save_krw_usd_to_db(krw_usd_data, db_path="symbols.db"):
    # DB 연결
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # ex_rate 테이블이 없다면 생성
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS ex_rate (
        timestamp DATETIME PRIMARY KEY,
        krw_usd REAL
    )
    ''')

    # KRW/USD 데이터가 비어 있지 않다면 DB에 저장
    if not krw_usd_data.empty:
        krw_usd_data = krw_usd_data.ffill()
        for timestamp, row in krw_usd_data.iterrows():
            # timestamp를 datetime 형식으로 변환
            timestamp = timestamp.to_pydatetime()

            # row['KRW_USD'] 값이 Series일 수 있으므로 .values[0]을 사용하여 값을 추출
            cursor.execute('''
            REPLACE INTO ex_rate (timestamp, krw_usd) VALUES (?, ?)
            ''', (timestamp, row['KRW_USD'].values[0]))  # Series에서 값을 추출하여 저장

        # 변경 사항 커밋
        conn.commit()

    # DB 연결 종료
    conn.close()

def save_krw_usdt_to_db(krw_usdt_data, db_path="symbols.db"):
    # DB 연결
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # ex_rate 테이블이 없다면 생성
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS ex_usdt_rate (
        timestamp DATETIME PRIMARY KEY,
        krw_usdt REAL
    )
    ''')

    # KRW/USD 데이터가 비어 있지 않다면 DB에 저장
    if not krw_usdt_data.empty:
        krw_usdt_data = krw_usdt_data.ffill()
        for timestamp, row in krw_usdt_data.iterrows():
            # timestamp를 datetime 형식으로 변환
            timestamp = timestamp.to_pydatetime()

            # row['KRW_USDT'] 값이 Series일 수 있으므로 .values[0]을 사용하여 값을 추출
            cursor.execute('''
            REPLACE INTO ex_usdt_rate (timestamp, krw_usdt) VALUES (?, ?)
            ''', (timestamp, row['KRW-USDT']))  # Series에서 값을 추출하여 저장

        # 변경 사항 커밋
        conn.commit()

    # DB 연결 종료
    conn.close()

# 모든 심볼에 대해 데이터 가져오기 및 DB에 저장
def fetch_data_for_all_symbols(interval, day):
    symbols = get_all_symbols_from_db()

    for symbol in symbols:
        print(f"\nFetching data for {symbol}...")

        # Upbit 데이터 가져오기
        upbit_data = get_upbit_close_data(symbol, interval, day)
        print(f"Upbit {symbol} 데이터:")
        print(upbit_data.head())
        print(upbit_data.tail()) # 상위 5개 행 출력


        # Bybit 데이터 가져오기
        bybit_data = get_bybit_close_data(symbol, interval, day)
        print(f"Bybit {symbol} 데이터:")
        print(bybit_data.head())
        print(bybit_data.tail()) # 상위 5개 행 출력

        save_to_db(symbol, bybit_data, upbit_data)
        print(f"Data saved to DB for {symbol}")


# 호출 예시
day = 50 # 예시로 5일
interval = 60  # 1분 간격


# KRW-USD 데이터 처리
krw_usd_data = fetch_krw_usd_multiple_requests(interval, day)
krw_usdt_data = get_usdt(interval, day)
print(f"KRW-USD 데이터:")
print(krw_usd_data.head())
print(krw_usdt_data.head())  # 상위 5개 행 출력

# DB 저장 시 KRW-USD는 별도로 처리
save_krw_usd_to_db(krw_usd_data)  # KRW-USD 데이터를 DB에 저장
save_krw_usdt_to_db(krw_usdt_data)
fetch_data_for_all_symbols(interval, day)

# import sqlite3

# # 데이터베이스 연결
# conn = sqlite3.connect('symbols.db')
# cursor = conn.cursor()

# # AAVE 테이블의 열 정보 확인
# cursor.execute("PRAGMA table_info(ex_rate);")
# columns = cursor.fetchall()

# # 열 이름 출력
# print("AAVE 테이블 열 이름:")
# for column in columns:
#     print(column[1])  # 열 이름은 두 번째 인덱스에 위치

# # AAVE 테이블의 데이터 일부 확인
# cursor.execute("SELECT * FROM ex_rate LIMIT 5000;")  # 상위 5개 데이터만 출력
# data = cursor.fetchall()

# # 데이터 출력
# print("\nAAVE 테이블 데이터 일부:")
# for row in data:
#     print(row)

# # 연결 종료
# conn.close()

# import sqlite3

# # 연결 종료
# conn = sqlite3.connect('symbols.db')
# conn.close()  # 잠긴 연결을 명시적으로 종료

# import sqlite3

# # 데이터베이스 연결
# conn = sqlite3.connect('symbols.db')
# cursor = conn.cursor()

# # 예시: 특정 심볼에 대한 데이터를 조회하는 쿼리
# symbol = 'AAVE'  # 확인하고 싶은 심볼
# table_name = f"'{symbol}'"  # 테이블 이름

# # 데이터 조회 쿼리 실행
# cursor.execute(f"SELECT * FROM '{symbol}'")
# rows = cursor.fetchall()

# # 결과 출력
# if rows:
#     for row in rows:
#         print(row)
# else:
#     print(f"{symbol}에 대한 데이터가 없습니다.")

# # # 예시: KRW/USD 데이터 조회
# # cursor.execute("SELECT * FROM ex_usdt_rate")
# # krw_usdt_data = cursor.fetchall()

# # # 결과 출력
# # if krw_usdt_data:
# #     for row in krw_usdt_data:
# #         print(row)
# # else:
# #     print("KRW/USDT 데이터가 없습니다.")

# # # 예시: KRW/USD 데이터 조회
# # cursor.execute("SELECT * FROM ex_usdt_rate")
# # krw_usd_data = cursor.fetchall()

# # # 결과 출력
# # if krw_usdt_data:
# #     for row in krw_usdt_data:
# #         print(row)
# # else:
# #     print("KRW/USD 데이터가 없습니다.")




# # 연결 종료
# conn.close()

import sqlite3

# 데이터베이스 연결
conn = sqlite3.connect('symbols.db')
cursor = conn.cursor()

# 'symbols' 테이블에서 symbol 가져오기
cursor.execute('SELECT symbol FROM symbols')
symbols = cursor.fetchall()

# 실제 데이터베이스에 존재하는 테이블 목록 가져오기
cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
all_tables = [table[0] for table in cursor.fetchall()]

# 각 symbol에 대해 작업 실행
for symbol in symbols:
    symbol_name = symbol[0]  # 예: '1INCH'

    # 'symbol' 테이블이 실제로 존재하는지 확인
    if symbol_name in all_tables:
        # 해당 테이블의 열 정보 확인
        cursor.execute(f"PRAGMA table_info('{symbol_name}')")
        columns = [column[1] for column in cursor.fetchall()]

        # 'bybit_close_krw_usd' 열이 없으면 추가
        if 'bybit_close_krw_usd' not in columns:
            cursor.execute(f'ALTER TABLE "{symbol_name}" ADD COLUMN bybit_close_krw_usd REAL')

        # 'bybit_close_krw_usdt' 열이 없으면 추가
        if 'bybit_close_krw_usdt' not in columns:
            cursor.execute(f'ALTER TABLE "{symbol_name}" ADD COLUMN bybit_close_krw_usdt REAL')

        # 'kimchi_premium_usd' 열이 없으면 추가 (기존 김프 계산용)
        if 'kimchi_premium_usd' not in columns:
            cursor.execute(f'ALTER TABLE "{symbol_name}" ADD COLUMN kimchi_premium_usd REAL')

        # 'kimchi_premium_usdt' 열이 없으면 추가 (새로운 김프 계산용)
        if 'kimchi_premium_usdt' not in columns:
            cursor.execute(f'ALTER TABLE "{symbol_name}" ADD COLUMN kimchi_premium_usdt REAL')

        # 'symbol'와 'ex_rate' 테이블을 timestamp 기준으로 조인하여 bybit_close * KRW_USD 값을 업데이트
        cursor.execute(f'''
            UPDATE "{symbol_name}"
            SET bybit_close_krw_usd = (
                SELECT bybit_close * KRW_USD
                FROM "ex_rate"
                WHERE "ex_rate".timestamp = "{symbol_name}".timestamp
            )
        ''')

        # 'symbol'와 'ex_usdt_rate' 테이블을 timestamp 기준으로 조인하여 bybit_close * KRW_USDT 값을 업데이트
        cursor.execute(f'''
            UPDATE "{symbol_name}"
            SET bybit_close_krw_usdt = (
                SELECT bybit_close * KRW_USDT
                FROM "ex_usdt_rate"
                WHERE "ex_usdt_rate".timestamp = "{symbol_name}".timestamp
            )
        ''')

        # 'symbol'와 'ex_rate' 테이블을 timestamp 기준으로 조인하여 bybit_close * KRW_USD 값을 사용하여 김프 계산
        cursor.execute(f'''
            UPDATE "{symbol_name}"
            SET kimchi_premium_usd = (
                SELECT (upbit_close / bybit_close_krw_usd - 1) * 100
                FROM "ex_rate"
                WHERE "ex_rate".timestamp = "{symbol_name}".timestamp
            )
        ''')

        # 'symbol'와 'ex_usdt_rate' 테이블을 timestamp 기준으로 조인하여 bybit_close * KRW_USDT 값을 사용하여 김프 계산
        cursor.execute(f'''
            UPDATE "{symbol_name}"
            SET kimchi_premium_usdt = (
                SELECT (upbit_close / bybit_close_krw_usdt - 1) * 100
                FROM "ex_usdt_rate"
                WHERE "ex_usdt_rate".timestamp = "{symbol_name}".timestamp
            )
        ''')

# 변경사항 커밋 및 연결 종료
conn.commit()
conn.close()

# import sqlite3
# import pandas as pd
# import matplotlib.pyplot as plt

# # SQLite DB 연결
# conn = sqlite3.connect('symbols.db')
# cursor = conn.cursor()

# # 'AAVE' 테이블에서 kimchi_premium_usd 값을 가져오기
# query = "SELECT timestamp, kimchi_premium_usd FROM 'AAVE'"
# cursor.execute(query)

# # 데이터 가져오기
# data = cursor.fetchall()

# # 커넥션 종료
# conn.close()

# # 데이터프레임으로 변환
# df = pd.DataFrame(data, columns=['timestamp', 'kimchi_premium_usd'])

# # timestamp를 datetime 형식으로 변환 (unit='s' 제거)
# df['timestamp'] = pd.to_datetime(df['timestamp'])

# # 그래프 그리기
# plt.figure(figsize=(10, 6))
# plt.plot(df['timestamp'], df['kimchi_premium_usd'], label='Kimchi Premium (usd)')
# plt.xlabel('Timestamp')
# plt.ylabel('Kimchi Premium (usd)')
# plt.title('Kimchi Premium (usd) for AAVE')
# plt.legend()
# plt.grid(True)
# plt.xticks(rotation=45)
# plt.tight_layout()

# # 그래프 표시
# plt.show()

# # SQLite DB 연결
# conn = sqlite3.connect('symbols.db')
# cursor = conn.cursor()

# # 'AAVE' 테이블에서 kimchi_premium_usdt 값을 가져오기
# query = "SELECT timestamp, kimchi_premium_usdt FROM 'AAVE'"
# cursor.execute(query)

# # 데이터 가져오기
# data = cursor.fetchall()

# # 커넥션 종료
# conn.close()

# # 데이터프레임으로 변환
# df = pd.DataFrame(data, columns=['timestamp', 'kimchi_premium_usdt'])

# # timestamp를 datetime 형식으로 변환 (unit='s' 제거)
# df['timestamp'] = pd.to_datetime(df['timestamp'])

# # 그래프 그리기
# plt.figure(figsize=(10, 6))
# plt.plot(df['timestamp'], df['kimchi_premium_usdt'], label='Kimchi Premium (USDT)')
# plt.xlabel('Timestamp')
# plt.ylabel('Kimchi Premium (USDT)')
# plt.title('Kimchi Premium (USDT) for AAVE')
# plt.legend()
# plt.grid(True)
# plt.xticks(rotation=45)
# plt.tight_layout()

# # 그래프 표시
# plt.show()